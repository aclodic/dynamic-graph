<HTML>
    <HEAD>
      <TITLE>dynamicGraph library documentation</TITLE>
      <LINK HREF="package.css" REL="stylesheet" TYPE="text/css">
      <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY>

<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>dynamic-graph library Documentation</h1>  </div>
</div>
<div class="contents">
<h3 class="version">1.0.0.99 </h3><h2><a class="anchor" id="intro_dynamicGraph"></a>
Introduction</h2>
<p>The dynamic-graph package is used to connect computation nodes, "entities" together using a graph system, akin to what Simulink does. With the building blocks this package provides, you can easily create a full computation graph for a given problem. It is the basis for the stack of tasks operation.</p>
<h2><a class="anchor" id="overview"></a>
Code overview</h2>
<p>This code implements the factory design pattern, making creation of entities available to packages depending on the dynamic-graph API.</p>
<p>Objects, which are derived from Entities (base class <a class="el" href="classdynamicgraph_1_1_entity.html" title="This class represents an entity, i.e. a generic computational unit that provides input and output sig...">dynamicgraph::Entity</a>), can be declared within the code and compiled to shared libraries (.so/.dll files). These libraries can be loaded at run-time using the PluginLoader methods, and at the same time register their class names to the Factory (see the examples in the SOT documentation to learn how).</p>
<p>The Factory can then create instances of these objects and subsequently register them in the Pool, where they can be listed, accessed, and acted upon (see sotPoolStorage documentation). Basic commands defined by entities include signal connection graph file generation, help and name print, and signals.</p>
<p>Finally, a shell (command-line) interface is made available thanks to the Interpreter class (see the file test_shell.cpp for an example). Objects deriving from Entity can expose their own commands by overriding the Entity's default commandLine() method. It is possible to load a plugin to register custom shell commands; see shell-functions and shell-procedure for an example.</p>
<p>Some basic shell functions, and support for procedures, are also included. For a complete list of those, load the plugin shell-functions.so and type 'help' at the command line.</p>
<p>The public static objects (singletons) made available by including the corresponding headers in this module are: </p>
<ul>
<li>g_factory: <a class="el" href="classdynamicgraph_1_1_factory_storage.html" title="The Factory class is responsible for creating Entity objects.">dynamicgraph::FactoryStorage</a> </li>
<li>g_pool: <a class="el" href="classdynamicgraph_1_1_pool_storage.html" title="This class keep tracks of all the objects in the stack of Tasks.">dynamicgraph::PoolStorage</a> </li>
<li>g_shell: <a class="el" href="classdynamicgraph_1_1_interpreter.html" title="This class implements the first level interpretor to control basic functionnalities of the plugins...">dynamicgraph::Interpreter</a></li>
</ul>
<h2><a class="anchor" id="entities"></a>
List of entities in this package</h2>
<p>Since most of the functionality in projects using the dynamic-graph framework is exposed from entities, here is a short description of all the entities contained in this package. Note that most entities are contained in a binary file that closely matches the entities' names in the scripts; loading this file with the plugin loader will enable creation of this entity through the factory. </p>
<ul>
<li><a class="el" href="tracerdoc.html">Tracer</a> </li>
<li><a class="el" href="tracerrealtimedoc.html">TracerRealTime</a> </li>
<li><a class="el" href="class_shell_procedure.html" title="This plugin exposes shell commands relative to the script language constructs such as procedures and ...">ShellProcedure</a> </li>
<li><a class="el" href="shellfunctions_doc.html">ShellFunctions</a> </li>
<li><a class="el" href="classdynamicgraph_1_1_contiifstream.html">Contiifstream </a></li>
</ul>
<p>The entities will be placed in ${PREFIX}/lib/plugin (since this may change, it is advised to check the install log or the CMakeLists.txt file to check the installation path). </p>
<h2><a class="anchor" id="sigintro"></a>
About signals</h2>
<p>Entities can output different types of signals. All signals are templated by a Time tick type parameter (which is used in the caching of signals) - usually <code>int</code>. Signals are also templated after the type of data they accept or provide. For example: (example) For a more detailed programmer-oriented description of signals, please see <a class="el" href="group__signals.html">Signals</a></p>
<h2><a class="anchor" id="scriptingabout"></a>
About the scripting language</h2>
<p>(...)</p>
<h2><a class="anchor" id="usecase"></a>
Programmers use case</h2>
<div align="center">
<img src="pictures/use-case.svg" alt="use-case.svg"/>
</div>
 </div>
 <br><br>
 <hr>
 <center>
 <img src="./pictures/footer.jpg" Height=100>
 <br>dynamicGraph library documentation</br>
 </center>
 <hr>
 </center>
 </body>
 </head>

